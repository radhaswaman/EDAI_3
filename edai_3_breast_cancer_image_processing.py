# -*- coding: utf-8 -*-
"""EDAI_3_BREAST CANCER IMAGE PROCESSING.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZhOtObOkN9Qu5zKpkfklt7-YhzsjcG7
"""

from google.colab import drive
drive.mount('/content/gdrive')

dataset_path = "/content/gdrive/MyDrive/Dataset_BUSI_with_GT"

import tensorflow as tf
ds_train = tf.keras.preprocessing.image_dataset_from_directory(
    dataset_path,
    validation_split=0.2,
    subset="training",
    seed=123,
    image_size=(256, 256),
    batch_size=32
)

ds_validation = tf.keras.preprocessing.image_dataset_from_directory(
    dataset_path,
    validation_split=0.2,
    subset="validation",
    seed=123,
    image_size=(256, 256),
    batch_size=32
)

# Function to merge labels and apply one-hot encoding
def merge_labels(x, y):
    # Create a one-hot encoded vector for three classes: [benign, malignant, normal]
    y = tf.one_hot(y, depth=3)  # 0: benign, 1: malignant, 2: normal
    return x, y

# Apply the label merging and one-hot encoding to both training and validation datasets
ds_train = ds_train.map(merge_labels)
ds_validation = ds_validation.map(merge_labels)

# Normalize the pixel values to the range [0, 1]
def normalize(image, label):
    image = tf.cast(image, tf.float32) / 255.0  # Scale pixel values
    return image, label

# Apply normalization
ds_train = ds_train.map(normalize)
ds_validation = ds_validation.map(normalize)

data_augmentation = tf.keras.Sequential([
    tf.keras.layers.RandomFlip("horizontal_and_vertical"),
    tf.keras.layers.RandomRotation(0.2),
])

# Apply data augmentation to the training dataset
ds_train = ds_train.map(lambda x, y: (data_augmentation(x, training=True), y))

# Prefetching for performance
AUTOTUNE = tf.data.AUTOTUNE
ds_train = ds_train.prefetch(buffer_size=AUTOTUNE)
ds_validation = ds_validation.prefetch(buffer_size=AUTOTUNE)

# Define the CNN model
model = tf.keras.Sequential([
    tf.keras.layers.Input(shape=(256, 256, 3)),
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),

    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),

    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(pool_size=(2, 2)),

    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(3, activation='softmax')  # Output layer for three classes
])

# Compile the model
model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',  # Use categorical crossentropy for multi-class classification
    metrics=['accuracy']
)

# Summary of the model
model.summary()

# Train the model
history = model.fit(
    ds_train,
    validation_data=ds_validation,
    epochs=20  # Adjust epochs based on your requirements
)

# Plot the training history
import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))  # Set figure size for better visibility
plt.plot(history.history['accuracy'], label='Training Accuracy', color='blue')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', color='orange')
plt.title('Training and Validation Accuracy')  # Title of the plot
plt.xlabel('Epoch')  # X-axis label
plt.ylabel('Accuracy')  # Y-axis label
plt.xticks(range(0, 31, 5))  # Set x-ticks for clarity
plt.legend(loc='lower right')  # Legend position
plt.grid(True)  # Add grid for better readability
plt.show()  # Display the plot

val_loss, val_acc = model.evaluate(ds_validation)
print(f"Validation Accuracy: {val_acc * 100:.2f}%")

# Save the model
model_save_path = '/content/gdrive/MyDrive/breast_cancer_cnn_model.h5'  # Specify the path where you want to save the model
model.save(model_save_path)

print(f"Model saved to {model_save_path}")

import matplotlib.pyplot as plt

# Function to display images from the dataset
def display_images(dataset, num_images=9):
    plt.figure(figsize=(10, 10))

    # Iterate through the dataset and display images
    for images, labels in dataset.take(1):  # Take one batch of images and labels
        for i in range(num_images):
            ax = plt.subplot(3, 3, i + 1)  # Create a 3x3 grid for displaying images

            # Convert the image to uint8 format for proper display
            image = (images[i] * 255).numpy().astype('uint8')  # Scale and convert to uint8
            plt.imshow(image)  # Display the image

            # Display the label
            plt.title(f"Label: {labels[i].numpy().argmax()}")
            plt.axis("off")  # Hide axes

    plt.show()

# Display images from the training dataset
display_images(ds_train, num_images=9)  # Change num_images to display more or fewer images

#MODEL EVALUATION
import os
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image

# Load the trained model
model_save_path = '/content/gdrive/MyDrive/breast_cancer_cnn_model.h5'  # Adjust the path as necessary
model = tf.keras.models.load_model(model_save_path)

# Function to preprocess the image
def preprocess_image(img_path):
    img = image.load_img(img_path, target_size=(256, 256))  # Resize to match model input
    img_array = image.img_to_array(img)  # Convert to array
    img_array = img_array / 255.0  # Normalize to [0, 1]
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
    return img_array

# Function to predict image class
def predict_image_class(img_path):
    img_array = preprocess_image(img_path)
    predictions = model.predict(img_array)
    class_idx = np.argmax(predictions[0])  # Get index of the highest probability
    return class_idx

# Function to display prediction results
def display_predictions(image_paths):
    class_names = ['Benign', 'Malignant', 'Normal']  # Adjust class names based on your dataset
    plt.figure(figsize=(10, 10))

    for i, img_path in enumerate(image_paths):
        ax = plt.subplot(3, 3, i + 1)
        img = image.load_img(img_path, target_size=(256, 256))  # Load and resize the image
        plt.imshow(img)  # Display the image

        # Get prediction
        class_idx = predict_image_class(img_path)

        # Extract the actual class from the image filename
        true_label = os.path.basename(img_path).split('_')[0]  # Assumes filename format like 'benign_01.jpg'
        true_class_idx = class_names.index(true_label.capitalize())  # Match with class names

        # Display predicted and true labels
        plt.title(f"Predicted: {class_names[class_idx]}\nTrue: {class_names[true_class_idx]}")
        plt.axis("off")  # Hide axes

    plt.show()

import os
import tensorflow as tf
from tensorflow.keras.preprocessing import image
import numpy as np

# Define the path to the image folder
test_image_dir = "/content/gdrive/MyDrive/Predict_Images"

# Define the class names
class_names = ["Benign", "Malignant", "Normal"]

# Load image paths
image_paths = [os.path.join(test_image_dir, fname) for fname in os.listdir(test_image_dir) if fname.endswith(('jpg', 'png'))]

# Check model's expected input shape
input_shape = model.input_shape[1:3]  # e.g., (224, 224) or any other shape your model expects

# Function to preprocess image and make predictions
def predict_image_class(img_path, model):
    # Load and preprocess the image
    img = image.load_img(img_path, target_size=input_shape)  # Adjust to model's expected shape
    img_array = image.img_to_array(img) / 255.0  # Normalize the image
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension

    # Predict
    predictions = model.predict(img_array)
    predicted_class = class_names[np.argmax(predictions)]
    confidence = np.max(predictions)

    return predicted_class, confidence

# Loop through images and display predictions
for img_path in image_paths:
    # Extract the true label from the filename (e.g., benign01.jpg -> Benign)
    base_name = os.path.basename(img_path).split('0')[0]  # Extracts 'benign', 'malignant', 'normal'
    true_label = base_name.capitalize()

    # Make predictions
    try:
        predicted_class, confidence = predict_image_class(img_path, model)
        # Print or display results
        print(f"Image: {img_path}")
        print(f"True label: {true_label}")
        print(f"Predicted: {predicted_class} with confidence {confidence:.2f}\n")
    except Exception as e:
        print(f"Error processing {img_path}: {e}")